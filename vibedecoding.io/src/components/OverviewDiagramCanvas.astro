---
interface Props {
  class?: string;
}
const { class: className } = Astro.props;
---

<div class:list={['overview-diagram-canvas', className]}>
  <canvas id="streamCanvas" width="900" height="400"></canvas>

  <!-- SVG overlay for labels, agents, and particles -->
  <svg class="overlay" viewBox="0 0 900 400">
    <defs>
      <!-- Particle glow gradients -->
      <radialGradient id="particleGlow" cx="50%" cy="50%" r="50%">
        <stop offset="0%" stop-color="#60a5fa" stop-opacity="1" />
        <stop offset="60%" stop-color="#3b82f6" stop-opacity="0.7" />
        <stop offset="100%" stop-color="#1d4ed8" stop-opacity="0" />
      </radialGradient>
      <radialGradient id="particleGlowLight" cx="50%" cy="50%" r="50%">
        <stop offset="0%" stop-color="#bfdbfe" stop-opacity="1" />
        <stop offset="60%" stop-color="#93c5fd" stop-opacity="0.7" />
        <stop offset="100%" stop-color="#60a5fa" stop-opacity="0" />
      </radialGradient>
      <!-- Agent box gradient -->
      <linearGradient id="agentGradient" x1="0%" y1="0%" x2="0%" y2="100%">
        <stop offset="0%" stop-color="#f8fafc" />
        <stop offset="100%" stop-color="#e2e8f0" />
      </linearGradient>
    </defs>

    <!-- Left Inputs -->
    <g class="inputs" fill="#64748b" font-size="14" font-family="system-ui, sans-serif">
      <!-- Voice Notes - Microphone icon -->
      <g transform="translate(15, 110)">
        <g transform="translate(0, -13) scale(1.8)">
          <path d="M8 1a3 3 0 0 0-3 3v4a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" fill="#3b82f6"/>
          <path d="M13 8a5 5 0 0 1-10 0M8 13v2M6 15h4" stroke="#3b82f6" stroke-width="1" fill="none" stroke-linecap="round"/>
        </g>
        <text x="35" y="5" fill="#475569" font-weight="500">Voice Notes</text>
      </g>
      <!-- Links - Chain link icon -->
      <g transform="translate(15, 155)">
        <g transform="translate(-3, -17) scale(1.8)">
          <path d="M10 6H6a4 4 0 0 0 0 8h1M8 10h4M12 6h1a4 4 0 0 1 0 8h-3" stroke="#3b82f6" stroke-width="1.1" fill="none" stroke-linecap="round"/>
        </g>
        <text x="35" y="5" fill="#475569" font-weight="500">Links</text>
      </g>
      <!-- Annotations - Document/notes icon -->
      <g transform="translate(15, 200)">
        <g transform="translate(0, -13) scale(1.8)">
          <rect x="2" y="1" width="12" height="14" rx="1.5" stroke="#3b82f6" stroke-width="1" fill="none"/>
          <path d="M5 5h6M5 8h6M5 11h4" stroke="#3b82f6" stroke-width="0.8" stroke-linecap="round"/>
        </g>
        <text x="35" y="5" fill="#475569" font-weight="500">Annotations</text>
      </g>
      <!-- Location - Map pin icon -->
      <g transform="translate(15, 245)">
        <g transform="translate(0, -13) scale(1.8)">
          <path d="M8 1C5.2 1 3 3.2 3 6c0 4 5 9 5 9s5-5 5-9c0-2.8-2.2-5-5-5z" stroke="#3b82f6" stroke-width="1" fill="none"/>
          <circle cx="8" cy="6" r="2" fill="#3b82f6"/>
        </g>
        <text x="35" y="5" fill="#475569" font-weight="500">Location</text>
      </g>
      <!-- Sensors - Radio/broadcast signal icon -->
      <g transform="translate(15, 290)">
        <g transform="translate(2, -13) scale(1.8)">
          <circle cx="8" cy="8" r="2" fill="#3b82f6"/>
          <path d="M4.5 4.5a5 5 0 0 1 7 0" stroke="#3b82f6" stroke-width="1" fill="none" stroke-linecap="round"/>
          <path d="M4.5 11.5a5 5 0 0 0 7 0" stroke="#3b82f6" stroke-width="1" fill="none" stroke-linecap="round"/>
          <path d="M2 2a8.5 8.5 0 0 1 12 0" stroke="#3b82f6" stroke-width="1" fill="none" stroke-linecap="round"/>
          <path d="M2 14a8.5 8.5 0 0 0 12 0" stroke="#3b82f6" stroke-width="1" fill="none" stroke-linecap="round"/>
        </g>
        <text x="35" y="5" fill="#475569" font-weight="500">Sensors</text>
      </g>
    </g>

    <!-- Right Outputs - centered on stream (Y=200) -->
    <g class="outputs" fill="#64748b" font-size="14" font-family="system-ui, sans-serif">
      <!-- Reminders - Bell/notification icon -->
      <g transform="translate(755, 130)">
        <g transform="translate(0, -15) scale(2.1)">
          <path d="M8 2a4 4 0 0 0-4 4c0 2-1 3.5-1.5 4.5h11c-.5-1-1.5-2.5-1.5-4.5a4 4 0 0 0-4-4z" stroke="#f59e0b" stroke-width="0.9" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M6 10.5c0 1.1.9 2 2 2s2-.9 2-2" stroke="#f59e0b" stroke-width="0.9" fill="none" stroke-linecap="round"/>
        </g>
        <text x="40" y="5" fill="#475569" font-weight="500">Reminders</text>
      </g>
      <!-- Intents - Target/crosshair icon -->
      <g transform="translate(755, 175)">
        <g transform="translate(0, -15) scale(2.1)">
          <circle cx="8" cy="8" r="5" stroke="#22c55e" stroke-width="0.9" fill="none"/>
          <circle cx="8" cy="8" r="2" stroke="#22c55e" stroke-width="0.9" fill="none"/>
          <circle cx="8" cy="8" r="0.8" fill="#22c55e"/>
        </g>
        <text x="40" y="5" fill="#475569" font-weight="500">Intents</text>
      </g>
      <!-- Insights - Lightbulb icon -->
      <g transform="translate(755, 220)">
        <g transform="translate(0, -15) scale(2.1)">
          <path d="M8 2a4 4 0 0 0-2.5 7v1.5h5V9a4 4 0 0 0-2.5-7z" stroke="#6366f1" stroke-width="0.9" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M6 11h4M6.5 12.5h3" stroke="#6366f1" stroke-width="0.7" fill="none" stroke-linecap="round"/>
        </g>
        <text x="40" y="5" fill="#475569" font-weight="500">Insights</text>
      </g>
      <!-- Knowledge - Book icon -->
      <g transform="translate(755, 265)">
        <g transform="translate(-2, -15) scale(2.1)">
          <path d="M2 3h4.5a2.5 2.5 0 0 1 2.5 2.5v8a1.5 1.5 0 0 0-1.5-1.5H2z" stroke="#ec4899" stroke-width="0.9" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M14 3H9.5A2.5 2.5 0 0 0 7 5.5v8a1.5 1.5 0 0 1 1.5-1.5H14z" stroke="#ec4899" stroke-width="0.9" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        </g>
        <text x="40" y="5" fill="#475569" font-weight="500">Knowledge</text>
      </g>
    </g>

    <!-- Stream Label -->
    <text x="450" y="205" text-anchor="middle" fill="white" font-size="14" font-weight="600" font-family="system-ui, sans-serif" style="text-shadow: 0 1px 3px rgba(0,0,0,0.3);">Event Stream</text>

    <!-- Agent Boxes - centered between stream label and edges -->
    <g class="agents">
      <g transform="translate(290, 90)" class="agent">
        <rect x="-50" y="-18" width="100" height="36" rx="8" fill="url(#agentGradient)" stroke="#94a3b8" stroke-width="1.5" />
        <text x="0" y="5" text-anchor="middle" fill="#334155" font-size="12" font-weight="500" font-family="system-ui, sans-serif">Materializer</text>
      </g>
      <g transform="translate(610, 90)" class="agent">
        <rect x="-40" y="-18" width="80" height="36" rx="8" fill="url(#agentGradient)" stroke="#94a3b8" stroke-width="1.5" />
        <text x="0" y="5" text-anchor="middle" fill="#334155" font-size="12" font-weight="500" font-family="system-ui, sans-serif">Fetcher</text>
      </g>
      <g transform="translate(290, 310)" class="agent">
        <rect x="-40" y="-18" width="80" height="36" rx="8" fill="url(#agentGradient)" stroke="#94a3b8" stroke-width="1.5" />
        <text x="0" y="5" text-anchor="middle" fill="#334155" font-size="12" font-weight="500" font-family="system-ui, sans-serif">Enricher</text>
      </g>
      <g transform="translate(610, 310)" class="agent">
        <rect x="-60" y="-18" width="120" height="36" rx="8" fill="url(#agentGradient)" stroke="#94a3b8" stroke-width="1.5" />
        <text x="0" y="5" text-anchor="middle" fill="#334155" font-size="12" font-weight="500" font-family="system-ui, sans-serif">Pattern Detector</text>
      </g>
    </g>

    <!-- Animated Particles -->
    <g class="particles">
      <!-- Input particles -->
      <circle class="particle input-p1" r="6" fill="url(#particleGlow)" />
      <circle class="particle input-p1" r="6" fill="url(#particleGlow)" style="animation-delay: -1.5s" />
      <circle class="particle input-p2" r="5" fill="url(#particleGlowLight)" />
      <circle class="particle input-p2" r="5" fill="url(#particleGlowLight)" style="animation-delay: -1.2s" />
      <circle class="particle input-p3" r="6" fill="url(#particleGlow)" />
      <circle class="particle input-p3" r="6" fill="url(#particleGlow)" style="animation-delay: -2s" />
      <circle class="particle input-p4" r="5" fill="url(#particleGlowLight)" />
      <circle class="particle input-p4" r="5" fill="url(#particleGlowLight)" style="animation-delay: -1.8s" />
      <circle class="particle input-p5" r="6" fill="url(#particleGlow)" />
      <circle class="particle input-p5" r="6" fill="url(#particleGlow)" style="animation-delay: -0.8s" />

      <!-- Stream particles -->
      <circle class="particle stream-p1" r="5" fill="url(#particleGlow)" />
      <circle class="particle stream-p1" r="5" fill="url(#particleGlow)" style="animation-delay: -1s" />
      <circle class="particle stream-p2" r="4" fill="url(#particleGlowLight)" />
      <circle class="particle stream-p2" r="4" fill="url(#particleGlowLight)" style="animation-delay: -1.5s" />
      <circle class="particle stream-p3" r="5" fill="url(#particleGlow)" />
      <circle class="particle stream-p3" r="5" fill="url(#particleGlow)" style="animation-delay: -0.7s" />

      <!-- Agent particles - bidirectional flow -->
      <!-- Materializer: stream to agent -->
      <circle class="particle agent-m-up" r="4" fill="url(#particleGlow)" />
      <circle class="particle agent-m-up" r="4" fill="url(#particleGlow)" style="animation-delay: -1.5s" />
      <!-- Materializer: agent to stream -->
      <circle class="particle agent-m-down" r="4" fill="url(#particleGlowLight)" />
      <circle class="particle agent-m-down" r="4" fill="url(#particleGlowLight)" style="animation-delay: -0.8s" />

      <!-- Fetcher: stream to agent -->
      <circle class="particle agent-f-up" r="4" fill="url(#particleGlow)" />
      <circle class="particle agent-f-up" r="4" fill="url(#particleGlow)" style="animation-delay: -1.3s" />
      <!-- Fetcher: agent to stream -->
      <circle class="particle agent-f-down" r="4" fill="url(#particleGlowLight)" />
      <circle class="particle agent-f-down" r="4" fill="url(#particleGlowLight)" style="animation-delay: -0.6s" />

      <!-- Enricher: stream to agent -->
      <circle class="particle agent-e-down" r="4" fill="url(#particleGlow)" />
      <circle class="particle agent-e-down" r="4" fill="url(#particleGlow)" style="animation-delay: -1.1s" />
      <!-- Enricher: agent to stream -->
      <circle class="particle agent-e-up" r="4" fill="url(#particleGlowLight)" />
      <circle class="particle agent-e-up" r="4" fill="url(#particleGlowLight)" style="animation-delay: -0.5s" />

      <!-- Pattern Detector: stream to agent -->
      <circle class="particle agent-pd-down" r="4" fill="url(#particleGlow)" />
      <circle class="particle agent-pd-down" r="4" fill="url(#particleGlow)" style="animation-delay: -1.4s" />
      <!-- Pattern Detector: agent to stream -->
      <circle class="particle agent-pd-up" r="4" fill="url(#particleGlowLight)" />
      <circle class="particle agent-pd-up" r="4" fill="url(#particleGlowLight)" style="animation-delay: -0.7s" />

      <!-- Output particles -->
      <circle class="particle output-p1" r="5" fill="url(#particleGlow)" />
      <circle class="particle output-p1" r="5" fill="url(#particleGlow)" style="animation-delay: -1.3s" />
      <circle class="particle output-p2" r="5" fill="url(#particleGlow)" />
      <circle class="particle output-p2" r="5" fill="url(#particleGlow)" style="animation-delay: -1.8s" />
      <circle class="particle output-p3" r="5" fill="url(#particleGlow)" />
      <circle class="particle output-p3" r="5" fill="url(#particleGlow)" style="animation-delay: -0.6s" />
      <circle class="particle output-p4" r="5" fill="url(#particleGlow)" />
      <circle class="particle output-p4" r="5" fill="url(#particleGlow)" style="animation-delay: -2.2s" />
    </g>

    <!-- Caption -->
    <text x="450" y="375" text-anchor="middle" fill="#64748b" font-size="13" font-style="italic" font-family="system-ui, sans-serif">
      Agents observe, enrich, and loop context back
    </text>
  </svg>
</div>

<script>
  // Canvas stream animation
  const canvas = document.getElementById('streamCanvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  let animationId: number;
  let time = 0;

  // Configuration
  const config = {
    ribbonCount: 1,  // Single ribbon for unified look
    particleCount: 25,  // Reduced particle count
    sparkleCount: 35,   // Reduced sparkle particles
    streamY: 200,
    streamHeight: 50,
    speed: 0.02,
    // Background effects
    bgOrbCount: 5,
    bgWaveCount: 3,
    bgGlowCount: 8
  };

  // Particles for the stream effect
  interface Particle {
    x: number;
    y: number;
    speed: number;
    size: number;
    opacity: number;
    ribbonIndex: number;
  }

  // Sparkle particles - stationary twinkling dots
  interface Sparkle {
    x: number;
    y: number;
    baseY: number;
    size: number;
    phase: number;      // For twinkling animation
    twinkleSpeed: number;
    maxOpacity: number;
  }

  const particles: Particle[] = [];
  const sparkles: Sparkle[] = [];

  // Initialize particles
  for (let i = 0; i < config.particleCount; i++) {
    particles.push({
      x: Math.random() * 900,
      y: 0,
      speed: 0.5 + Math.random() * 1.5,
      size: 1 + Math.random() * 3,
      opacity: 0.3 + Math.random() * 0.7,
      ribbonIndex: Math.floor(Math.random() * config.ribbonCount)
    });
  }

  // Initialize sparkles throughout the stream area
  for (let i = 0; i < config.sparkleCount; i++) {
    const x = 140 + Math.random() * 620;  // Stream area
    sparkles.push({
      x,
      y: 0,
      baseY: config.streamY + (Math.random() - 0.5) * 50,  // Spread vertically (reduced from 80 to fit narrower stream)
      size: 0.5 + Math.random() * 2.5,
      phase: Math.random() * Math.PI * 2,
      twinkleSpeed: 0.03 + Math.random() * 0.05,
      maxOpacity: 0.4 + Math.random() * 0.6
    });
  }

  // Background effects
  interface BgOrb {
    x: number;
    y: number;
    size: number;
    phase: number;
    driftSpeed: number;
    pulseSpeed: number;
    color: {r: number, g: number, b: number};
    maxOpacity: number;
  }

  interface BgGlow {
    x: number;
    y: number;
    size: number;
    phase: number;
    fadeSpeed: number;
    color: {r: number, g: number, b: number};
    maxOpacity: number;
  }

  const bgOrbs: BgOrb[] = [];
  const bgGlows: BgGlow[] = [];

  // Subtle background colors - neutral light grays only
  const bgColors = [
    { r: 248, g: 250, b: 252 },  // slate-50
    { r: 241, g: 245, b: 249 },  // slate-100
    { r: 226, g: 232, b: 240 },  // slate-200
    { r: 248, g: 250, b: 252 },  // slate-50
  ];

  // Initialize background orbs - large, soft gradient circles
  // Use fixed positions for consistent placement
  const orbPositions = [
    { x: 150, y: 80 },    // top-left area
    { x: 750, y: 80 },    // top-right area
    { x: 120, y: 320 },   // bottom-left area
    { x: 780, y: 320 },   // bottom-right area
    { x: 450, y: 350 },   // bottom-center
  ];

  for (let i = 0; i < config.bgOrbCount; i++) {
    const pos = orbPositions[i % orbPositions.length];

    bgOrbs.push({
      x: pos.x,
      y: pos.y,
      size: 150 + (i * 20),  // Large orbs (150-230px)
      phase: i * 1.2,        // Staggered phases
      driftSpeed: 0.001,
      pulseSpeed: 0.008,
      color: bgColors[i % bgColors.length],
      maxOpacity: 0.35  // Much more visible
    });
  }

  // Initialize ambient glow spots - scattered around canvas
  for (let i = 0; i < config.bgGlowCount; i++) {
    bgGlows.push({
      x: 50 + Math.random() * 800,
      y: 50 + Math.random() * 300,
      size: 20 + Math.random() * 40,
      phase: Math.random() * Math.PI * 2,
      fadeSpeed: 0.02 + Math.random() * 0.03,
      color: bgColors[Math.floor(Math.random() * bgColors.length)],
      maxOpacity: 0.06 + Math.random() * 0.06
    });
  }

  // Get Y position for stream center at given x (matches main stream wave)
  function getStreamY(x: number, t: number): number {
    // Use same wave parameters as drawUnifiedStream for consistency
    // Reduced time multipliers for gentler, slower oscillation
    const wave1 = Math.sin(x * 0.008 + t * 0.25) * 12;
    const wave2 = Math.sin(x * 0.012 + t * 0.35) * 6;
    const wave3 = Math.sin(x * 0.005 + t * 0.15) * 4;

    return config.streamY + wave1 + wave2 + wave3;
  }

  // Color gradient: softer purple center, transitioning to light blue at edges
  const edgeColor = { r: 191, g: 219, b: 254 };    // Lighter blue at edges (blue-200)
  const centerColor = { r: 129, g: 140, b: 248 };  // Softer indigo (indigo-400)

  // Get color based on x position (more purple in center, blue at edges)
  function getColorAtX(x: number): {r: number, g: number, b: number} {
    const streamStart = 130;
    const streamEnd = 770;
    const streamMid = (streamStart + streamEnd) / 2;

    // Distance from center (0 at center, 1 at edges)
    const distFromCenter = Math.abs(x - streamMid) / ((streamEnd - streamStart) / 2);

    // Interpolate between center color (purple) and edge color (light blue)
    const t = Math.pow(distFromCenter, 0.7); // Ease the transition

    return {
      r: Math.round(centerColor.r + (edgeColor.r - centerColor.r) * t),
      g: Math.round(centerColor.g + (edgeColor.g - centerColor.g) * t),
      b: Math.round(centerColor.b + (edgeColor.b - centerColor.b) * t)
    };
  }

  // Draw soft gradient orbs near the agents
  function drawBackgroundOrbs() {
    // Orbs positioned near agents: Materializer (290,90), Fetcher (610,90), Enricher (290,310), Pattern Detector (610,310)
    // Using more neutral, warm-tinted colors (less saturated blue/purple)
    const orbConfigs = [
      { x: 290, y: 90, size: 180, color: { r: 226, g: 232, b: 240 } },   // near Materializer - warm gray
      { x: 610, y: 90, size: 160, color: { r: 241, g: 245, b: 249 } },   // near Fetcher - light slate
      { x: 290, y: 310, size: 170, color: { r: 248, g: 250, b: 252 } },  // near Enricher - near white
      { x: 610, y: 310, size: 180, color: { r: 226, g: 232, b: 240 } },  // near Pattern Detector - warm gray
    ];

    for (let i = 0; i < orbConfigs.length; i++) {
      const orb = orbConfigs[i];
      const phase = i * 1.5;

      // Gentle drifting motion
      const driftX = Math.sin(time * 0.05 + phase) * 8;
      const driftY = Math.cos(time * 0.04 + phase * 1.3) * 6;

      // Pulsing size
      const pulse = 0.95 + Math.sin(time * 0.4 + phase) * 0.05;
      const currentSize = orb.size * pulse;

      // Pulsing opacity
      const opacityPulse = 0.8 + Math.sin(time * 0.3 + phase * 0.7) * 0.2;
      const baseOpacity = 0.33;  // 33% opacity
      const currentOpacity = baseOpacity * opacityPulse;

      const x = orb.x + driftX;
      const y = orb.y + driftY;

      // Draw soft radial gradient orb
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, currentSize);
      gradient.addColorStop(0, `rgba(${orb.color.r}, ${orb.color.g}, ${orb.color.b}, ${currentOpacity})`);
      gradient.addColorStop(0.5, `rgba(${orb.color.r}, ${orb.color.g}, ${orb.color.b}, ${currentOpacity * 0.4})`);
      gradient.addColorStop(1, `rgba(${orb.color.r}, ${orb.color.g}, ${orb.color.b}, 0)`);

      ctx.beginPath();
      ctx.arc(x, y, currentSize, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }

  // Draw subtle flowing wave lines in the background
  function drawBackgroundWaves() {
    const waveConfigs = [
      { y: 70, amplitude: 8, frequency: 0.005, speed: 0.3, opacity: 0.06 },
      { y: 330, amplitude: 10, frequency: 0.004, speed: 0.25, opacity: 0.05 },
      { y: 370, amplitude: 6, frequency: 0.006, speed: 0.35, opacity: 0.04 },
    ];

    for (const wave of waveConfigs) {
      ctx.beginPath();

      for (let x = 0; x <= 900; x += 4) {
        const y = wave.y +
          Math.sin(x * wave.frequency + time * wave.speed) * wave.amplitude +
          Math.sin(x * wave.frequency * 1.5 + time * wave.speed * 0.7) * (wave.amplitude * 0.5);

        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }

      // Create gradient that fades at edges - neutral gray
      const gradient = ctx.createLinearGradient(0, 0, 900, 0);
      gradient.addColorStop(0, `rgba(203, 213, 225, 0)`);
      gradient.addColorStop(0.2, `rgba(203, 213, 225, ${wave.opacity})`);
      gradient.addColorStop(0.5, `rgba(226, 232, 240, ${wave.opacity * 1.2})`);
      gradient.addColorStop(0.8, `rgba(203, 213, 225, ${wave.opacity})`);
      gradient.addColorStop(1, `rgba(203, 213, 225, 0)`);

      ctx.strokeStyle = gradient;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  // Draw ambient glow spots that fade in and out
  function drawBackgroundGlows() {
    for (const glow of bgGlows) {
      // Fading in/out animation
      const fadePhase = Math.sin(time * glow.fadeSpeed * 50 + glow.phase);
      const currentOpacity = glow.maxOpacity * Math.max(0, fadePhase);

      // Only draw if visible
      if (currentOpacity > 0.01) {
        const gradient = ctx.createRadialGradient(glow.x, glow.y, 0, glow.x, glow.y, glow.size);
        gradient.addColorStop(0, `rgba(${glow.color.r}, ${glow.color.g}, ${glow.color.b}, ${currentOpacity})`);
        gradient.addColorStop(0.5, `rgba(${glow.color.r}, ${glow.color.g}, ${glow.color.b}, ${currentOpacity * 0.4})`);
        gradient.addColorStop(1, `rgba(${glow.color.r}, ${glow.color.g}, ${glow.color.b}, 0)`);

        ctx.beginPath();
        ctx.arc(glow.x, glow.y, glow.size, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
      }
    }
  }

  // Draw agent connection arrows on canvas (behind the stream)
  function drawAgentArrows() {
    const arrowColor = '#6385b0';
    const strokeWidth = 2;
    const opacity = 0.75;

    ctx.save();
    ctx.strokeStyle = arrowColor;
    ctx.lineWidth = strokeWidth;
    ctx.globalAlpha = opacity;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Arrow paths (quadratic bezier curves)
    const arrows = [
      // Materializer (top-left)
      { start: [250, 108], control: [200, 150], end: [260, 190] },
      { start: [330, 108], control: [380, 150], end: [320, 190] },
      // Fetcher (top-right)
      { start: [570, 108], control: [520, 150], end: [580, 190] },
      { start: [650, 108], control: [700, 150], end: [640, 190] },
      // Enricher (bottom-left)
      { start: [250, 292], control: [200, 250], end: [260, 210] },
      { start: [330, 292], control: [380, 250], end: [320, 210] },
      // Pattern Detector (bottom-right)
      { start: [570, 292], control: [520, 250], end: [580, 210] },
      { start: [650, 292], control: [700, 250], end: [640, 210] },
    ];

    for (const arrow of arrows) {
      const [sx, sy] = arrow.start;
      const [cx, cy] = arrow.control;
      const [ex, ey] = arrow.end;

      // Draw the curved line (no arrowheads - they're hidden behind the stream)
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.quadraticCurveTo(cx, cy, ex, ey);
      ctx.stroke();
    }

    ctx.restore();
  }

  function draw() {
    ctx.clearRect(0, 0, 900, 400);

    // Draw background effects first (behind everything)
    drawBackgroundOrbs();
    drawBackgroundWaves();
    drawBackgroundGlows();

    // Draw agent arrows behind the stream
    drawAgentArrows();

    const streamStart = 130;
    const streamEnd = 770;

    // Draw outer aurora glow (magical diffuse light)
    drawAuroraGlow(streamStart, streamEnd);

    // Draw shadow under the stream
    drawStreamShadow(streamStart, streamEnd);

    // Draw a single unified stream with internal flow variation
    drawUnifiedStream(streamStart, streamEnd);

    // Draw light accent streams on top of main stream
    drawLightAccentStreams();

    // Draw sparkles (twinkling background stars)
    drawSparkles();

    // Draw particles (moving dots)
    drawParticles();

    // Draw center glow
    drawCenterGlow();
  }

  // Draw a subtle glow effect around the stream
  function drawAuroraGlow(startX: number, endX: number) {
    // Softer, more subtle glow layers - less saturated
    const glowLayers = [
      { spread: 100, opacity: 0.04, color: { r: 203, g: 213, b: 225 } },  // Outer gray
      { spread: 70, opacity: 0.06, color: { r: 165, g: 180, b: 210 } },   // Mid muted blue-gray
      { spread: 45, opacity: 0.08, color: { r: 147, g: 160, b: 200 } },   // Inner muted blue
    ];

    for (const layer of glowLayers) {
      ctx.beginPath();

      // Create an elliptical glow path that follows the stream
      for (let x = startX; x <= endX; x += 5) {
        const baseY = getStreamY(x, time);
        const yOffset = Math.sin(x * 0.01 + time * 0.2) * 10;

        if (x === startX) {
          ctx.moveTo(x, baseY - layer.spread + yOffset);
        } else {
          ctx.lineTo(x, baseY - layer.spread + yOffset);
        }
      }

      // Bottom edge (reverse)
      for (let x = endX; x >= startX; x -= 5) {
        const baseY = getStreamY(x, time);
        const yOffset = Math.sin(x * 0.01 + time * 0.2) * 10;
        ctx.lineTo(x, baseY + layer.spread + yOffset);
      }

      ctx.closePath();

      // Radial-like gradient from center
      const gradient = ctx.createLinearGradient(startX, 0, endX, 0);
      const c = layer.color;
      gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, 0)`);
      gradient.addColorStop(0.15, `rgba(${c.r}, ${c.g}, ${c.b}, ${layer.opacity})`);
      gradient.addColorStop(0.5, `rgba(${c.r}, ${c.g}, ${c.b}, ${layer.opacity * 1.2})`);
      gradient.addColorStop(0.85, `rgba(${c.r}, ${c.g}, ${c.b}, ${layer.opacity})`);
      gradient.addColorStop(1, `rgba(${c.r}, ${c.g}, ${c.b}, 0)`);

      ctx.fillStyle = gradient;
      ctx.filter = 'blur(20px)';
      ctx.fill();
      ctx.filter = 'none';
    }
  }

  // Draw a soft shadow under the stream
  function drawStreamShadow(startX: number, endX: number) {
    const shadowOffset = 8;  // How far below the stream
    const shadowBlur = 15;   // Blur amount
    const streamWidth = 70;

    // Build shadow path (same shape as stream, offset down)
    ctx.beginPath();

    // Top edge of shadow
    for (let x = startX; x <= endX; x += 3) {
      const baseY = config.streamY + shadowOffset;
      const wave1 = Math.sin(x * 0.008 + time * 0.25) * 12;
      const wave2 = Math.sin(x * 0.012 + time * 0.35) * 6;
      const wave3 = Math.sin(x * 0.005 + time * 0.15) * 4;
      const waveOffset = wave1 + wave2 + wave3;
      const edgeWave = Math.sin(x * 0.015 + time * 0.12) * 6;
      const y = baseY + waveOffset - streamWidth/2 - edgeWave;

      if (x === startX) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    // Bottom edge of shadow (reverse)
    for (let x = endX; x >= startX; x -= 3) {
      const baseY = config.streamY + shadowOffset;
      const wave1 = Math.sin(x * 0.008 + time * 0.25) * 12;
      const wave2 = Math.sin(x * 0.012 + time * 0.35) * 6;
      const wave3 = Math.sin(x * 0.005 + time * 0.15) * 4;
      const waveOffset = wave1 + wave2 + wave3;
      const edgeWave = Math.sin(x * 0.015 + time * 0.12) * 6;
      const y = baseY + waveOffset + streamWidth/2 + edgeWave;

      ctx.lineTo(x, y);
    }

    ctx.closePath();

    // Apply shadow with blur
    ctx.save();
    ctx.filter = `blur(${shadowBlur}px)`;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    ctx.fill();
    ctx.restore();
  }

  // Draw a single unified stream as a filled shape with gradient
  function drawUnifiedStream(startX: number, endX: number) {
    const streamWidth = 60;  // Total stream height (slightly narrower)

    // Build top and bottom edge paths
    const topPoints: {x: number, y: number}[] = [];
    const bottomPoints: {x: number, y: number}[] = [];

    for (let x = startX; x <= endX; x += 3) {
      const baseY = config.streamY;

      // Flowing wave motion for edges (gentle, slow oscillation)
      const wave1 = Math.sin(x * 0.008 + time * 0.25) * 12;
      const wave2 = Math.sin(x * 0.012 + time * 0.35) * 6;
      const wave3 = Math.sin(x * 0.005 + time * 0.15) * 4;
      const waveOffset = wave1 + wave2 + wave3;

      // Edge undulation for organic shape (gentle)
      const edgeWave = Math.sin(x * 0.015 + time * 0.12) * 6;

      topPoints.push({ x, y: baseY + waveOffset - streamWidth/2 - edgeWave });
      bottomPoints.push({ x, y: baseY + waveOffset + streamWidth/2 + edgeWave });
    }

    // Draw filled stream shape with gradient
    // Multiple passes for smooth gradient from edge to center
    const passes = 20;

    for (let pass = 0; pass < passes; pass++) {
      const t = pass / (passes - 1);  // 0 at edges, 1 at center
      const shrink = t * 0.9;  // How much to shrink toward center

      ctx.beginPath();

      // Top edge
      for (let i = 0; i < topPoints.length; i++) {
        const tp = topPoints[i];
        const bp = bottomPoints[i];
        const midY = (tp.y + bp.y) / 2;
        const y = tp.y + (midY - tp.y) * shrink;

        if (i === 0) ctx.moveTo(tp.x, y);
        else ctx.lineTo(tp.x, y);
      }

      // Bottom edge (reverse order)
      for (let i = bottomPoints.length - 1; i >= 0; i--) {
        const tp = topPoints[i];
        const bp = bottomPoints[i];
        const midY = (tp.y + bp.y) / 2;
        const y = bp.y + (midY - bp.y) * shrink;

        ctx.lineTo(bp.x, y);
      }

      ctx.closePath();

      // Gradient fill - softer opacity for more subtle effect
      const opacity = 0.15 + t * 0.45;  // Reduced opacity for subtler appearance

      // Create horizontal gradient for this pass
      // Fade to transparent at start and end for smooth edges
      const gradient = ctx.createLinearGradient(startX, 0, endX, 0);
      const edgeC = edgeColor;
      const centerC = centerColor;
      // Interpolate between colors for smooth flowing gradient
      function lerpColor(c1: {r:number,g:number,b:number}, c2: {r:number,g:number,b:number}, t: number) {
        return {
          r: Math.round(c1.r + (c2.r - c1.r) * t),
          g: Math.round(c1.g + (c2.g - c1.g) * t),
          b: Math.round(c1.b + (c2.b - c1.b) * t)
        };
      }

      // Create many small stops for smooth continuous gradient
      const stops = 20;
      for (let i = 0; i <= stops; i++) {
        const pos = i / stops;
        // Map position to color: edges are blue, center is indigo
        // Use smooth sine curve for natural transition
        const distFromCenter = Math.abs(pos - 0.5) * 2; // 0 at center, 1 at edges
        const colorT = Math.pow(distFromCenter, 1.5); // Ease the transition

        const c = lerpColor(centerC, edgeC, colorT);

        // Opacity fades at edges
        let opacityMult = 1;
        if (pos < 0.1) opacityMult = pos / 0.1;
        else if (pos > 0.9) opacityMult = (1 - pos) / 0.1;

        gradient.addColorStop(pos, `rgba(${c.r}, ${c.g}, ${c.b}, ${opacity * opacityMult})`);
      }

      ctx.fillStyle = gradient;
      ctx.fill();
    }

    // Add internal flow lines for texture/movement
    drawInternalFlowLines(startX, endX, topPoints, bottomPoints);
  }

  // Draw subtle internal flow lines within the stream
  function drawInternalFlowLines(startX: number, endX: number, topPoints: {x: number, y: number}[], bottomPoints: {x: number, y: number}[]) {
    const lineCount = 4;

    for (let line = 0; line < lineCount; line++) {
      const t = (line + 1) / (lineCount + 1);  // Position from top to bottom

      ctx.beginPath();

      for (let i = 0; i < topPoints.length; i++) {
        const tp = topPoints[i];
        const bp = bottomPoints[i];

        // Interpolate between top and bottom
        const y = tp.y + (bp.y - tp.y) * t;

        // Add small wave variation for each line (slowed down)
        const lineWave = Math.sin(tp.x * 0.02 + time * 0.9 + line * 0.7) * 3;

        if (i === 0) ctx.moveTo(tp.x, y + lineWave);
        else ctx.lineTo(tp.x, y + lineWave);
      }

      // Get color at center for this line
      const color = getColorAtX((startX + endX) / 2);
      const opacity = 0.08 + Math.sin(line * 0.5 + time) * 0.03;

      ctx.strokeStyle = `rgba(${color.r + 50}, ${color.g + 50}, ${color.b + 50}, ${opacity})`;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  // Draw thin light accent streams at top and bottom edges
  function drawLightAccentStreams() {
    const streamStart = 140;
    const streamEnd = 760;

    // Subtle flowing streaks - gentle and understated
    const streakConfigs = [
      // Light indigo streak near top
      { yOffset: -12, width: 1, opacity: 0.15, phase: 0, freq: 0.01, amp: 8, speed: 0.25,
        color: { r: 199, g: 210, b: 254 } },  // Very light indigo
      // Softer violet streak in middle
      { yOffset: 5, width: 1.2, opacity: 0.12, phase: 2.0, freq: 0.012, amp: 6, speed: 0.3,
        color: { r: 167, g: 139, b: 250 } },  // Lighter violet
    ];

    for (const streak of streakConfigs) {
      const c = streak.color;
      // Create gradient that fades at edges
      const grad = ctx.createLinearGradient(streamStart, 0, streamEnd, 0);
      grad.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, 0)`);
      grad.addColorStop(0.15, `rgba(${c.r}, ${c.g}, ${c.b}, ${streak.opacity * 0.5})`);
      grad.addColorStop(0.35, `rgba(${c.r}, ${c.g}, ${c.b}, ${streak.opacity})`);
      grad.addColorStop(0.5, `rgba(${c.r}, ${c.g}, ${c.b}, ${streak.opacity * 1.1})`);
      grad.addColorStop(0.65, `rgba(${c.r}, ${c.g}, ${c.b}, ${streak.opacity})`);
      grad.addColorStop(0.85, `rgba(${c.r}, ${c.g}, ${c.b}, ${streak.opacity * 0.5})`);
      grad.addColorStop(1, `rgba(${c.r}, ${c.g}, ${c.b}, 0)`);

      ctx.beginPath();

      for (let x = streamStart; x <= streamEnd; x += 3) {
        const streamCenterY = getStreamY(x, time);
        const waveY = Math.sin(x * streak.freq + time * streak.speed + streak.phase) * streak.amp +
                      Math.sin(x * streak.freq * 0.6 + time * streak.speed * 1.2 + streak.phase * 0.5) * (streak.amp * 0.3);
        const y = streamCenterY + streak.yOffset + waveY;

        if (x === streamStart) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }

      ctx.strokeStyle = grad;
      ctx.lineWidth = streak.width;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
    }

    // Outer accent streams (subtle edge glow lines) - very light blue
    const outerAccentColor = { r: 209, g: 230, b: 254 };  // Very light blue
    const outerConfigs = [
      { yOffset: -55, width: 1.2, opacity: 0.18, phase: 0 },
      { yOffset: 55, width: 1.2, opacity: 0.18, phase: 2 },
    ];

    for (const outer of outerConfigs) {
      const grad = ctx.createLinearGradient(streamStart, 0, streamEnd, 0);
      grad.addColorStop(0, `rgba(${outerAccentColor.r}, ${outerAccentColor.g}, ${outerAccentColor.b}, 0)`);
      grad.addColorStop(0.15, `rgba(${outerAccentColor.r}, ${outerAccentColor.g}, ${outerAccentColor.b}, ${outer.opacity})`);
      grad.addColorStop(0.85, `rgba(${outerAccentColor.r}, ${outerAccentColor.g}, ${outerAccentColor.b}, ${outer.opacity})`);
      grad.addColorStop(1, `rgba(${outerAccentColor.r}, ${outerAccentColor.g}, ${outerAccentColor.b}, 0)`);

      ctx.beginPath();
      for (let x = streamStart; x <= streamEnd; x += 4) {
        const y = config.streamY + outer.yOffset +
          Math.sin(x * 0.01 + time * 0.2 + outer.phase) * 8 +
          Math.sin(x * 0.006 + time * 0.12 + outer.phase) * 4;

        if (x === streamStart) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }

      ctx.strokeStyle = grad;
      ctx.lineWidth = outer.width;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
    }
  }

  function drawParticles() {
    const streamHalfWidth = 25;  // Keep particles within narrower bounds than stream width (70/2 = 35)

    for (const p of particles) {
      // Update particle position
      p.x += p.speed;
      if (p.x > 800) {
        p.x = 100;
      }

      // Get Y from stream path with slight vertical offset for variety
      // Constrain offset to stay within stream bounds
      const verticalOffset = (p.ribbonIndex - 0.5) * streamHalfWidth * 0.6;
      p.y = getStreamY(p.x, time) + verticalOffset;

      // Draw particle with softer glow
      const adjustedOpacity = p.opacity * 0.7;  // Reduce overall opacity
      const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2.5);
      gradient.addColorStop(0, `rgba(255, 255, 255, ${adjustedOpacity * 0.9})`);
      gradient.addColorStop(0.4, `rgba(191, 219, 254, ${adjustedOpacity * 0.5})`);
      gradient.addColorStop(1, 'rgba(147, 197, 253, 0)');

      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }

  function drawSparkles() {
    for (const s of sparkles) {
      // Update sparkle y position to follow the stream center
      const streamCenterY = getStreamY(s.x, time);
      const offsetFromCenter = (s.baseY - config.streamY);  // Original offset from center
      s.y = streamCenterY + offsetFromCenter * 0.6;  // Apply reduced offset to stay in stream

      // Twinkling opacity - gentler twinkle
      const twinkle = Math.sin(time * s.twinkleSpeed * 60 + s.phase);
      const twinkle2 = Math.sin(time * s.twinkleSpeed * 90 + s.phase * 1.5);
      const combinedTwinkle = (twinkle + twinkle2 * 0.5) / 1.5;
      const opacity = s.maxOpacity * 0.6 * (0.2 + 0.8 * ((combinedTwinkle + 1) / 2));  // Reduced max opacity

      // Only show sparkle when it's "on" (above threshold)
      if (opacity > 0.12) {
        // Draw sparkle with softer glow
        const glowSize = s.size * 4;  // Smaller glow
        const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, glowSize);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${Math.min(0.8, opacity * 1.1)})`);
        gradient.addColorStop(0.2, `rgba(255, 255, 255, ${opacity * 0.7})`);
        gradient.addColorStop(0.5, `rgba(219, 234, 254, ${opacity * 0.3})`);
        gradient.addColorStop(1, 'rgba(191, 219, 254, 0)');

        ctx.beginPath();
        ctx.arc(s.x, s.y, glowSize, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Add a tiny bright center dot for extra sparkle - only for brighter ones
        if (opacity > 0.35) {
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(0.9, opacity * 1.4)})`;
          ctx.fill();
        }

        // Remove cross-hair sparkle lines for cleaner look
      }
    }
  }

  function drawCenterGlow() {
    // Horizontal center glow - softer
    const gradient = ctx.createLinearGradient(130, 0, 770, 0);
    gradient.addColorStop(0, 'rgba(219, 234, 254, 0)');
    gradient.addColorStop(0.3, 'rgba(219, 234, 254, 0.2)');
    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.25)');
    gradient.addColorStop(0.7, 'rgba(219, 234, 254, 0.2)');
    gradient.addColorStop(1, 'rgba(219, 234, 254, 0)');

    ctx.beginPath();
    ctx.moveTo(130, getStreamY(130, time));

    for (let x = 130; x <= 770; x += 5) {
      const y = getStreamY(x, time);
      ctx.lineTo(x, y);
    }

    ctx.strokeStyle = gradient;
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Bank highlights - bright white lines at the stream edges
    drawBankHighlights();
  }

  function drawBankHighlights() {
    const streamStart = 140;
    const streamEnd = 760;

    // Top bank highlight - follows the top edge of the stream (softer)
    const topGradient = ctx.createLinearGradient(streamStart, 0, streamEnd, 0);
    topGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
    topGradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.35)');
    topGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
    topGradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.35)');
    topGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

    ctx.beginPath();
    for (let x = streamStart; x <= streamEnd; x += 4) {
      // Follow the stream shape at the top edge
      const baseY = config.streamY;
      const wave1 = Math.sin(x * 0.008 + time * 0.25) * 12;
      const wave2 = Math.sin(x * 0.012 + time * 0.35) * 6;
      const wave3 = Math.sin(x * 0.005 + time * 0.15) * 4;
      const waveOffset = wave1 + wave2 + wave3;
      const edgeWave = Math.sin(x * 0.015 + time * 0.12) * 6;
      const y = baseY + waveOffset - 35 - edgeWave; // Top edge position

      if (x === streamStart) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.strokeStyle = topGradient;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Bottom bank highlight - follows the bottom edge of the stream (softer)
    const bottomGradient = ctx.createLinearGradient(streamStart, 0, streamEnd, 0);
    bottomGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
    bottomGradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.35)');
    bottomGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
    bottomGradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.35)');
    bottomGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

    ctx.beginPath();
    for (let x = streamStart; x <= streamEnd; x += 4) {
      // Follow the stream shape at the bottom edge
      const baseY = config.streamY;
      const wave1 = Math.sin(x * 0.008 + time * 0.25) * 12;
      const wave2 = Math.sin(x * 0.012 + time * 0.35) * 6;
      const wave3 = Math.sin(x * 0.005 + time * 0.15) * 4;
      const waveOffset = wave1 + wave2 + wave3;
      const edgeWave = Math.sin(x * 0.015 + time * 0.12) * 6;
      const y = baseY + waveOffset + 35 + edgeWave; // Bottom edge position

      if (x === streamStart) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.strokeStyle = bottomGradient;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.stroke();
  }

  function animate() {
    time += config.speed;
    draw();
    animationId = requestAnimationFrame(animate);
  }

  // Handle reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

  if (!prefersReducedMotion.matches) {
    animate();
  } else {
    draw(); // Draw static frame
  }

  // Cleanup on page navigation
  document.addEventListener('astro:before-swap', () => {
    cancelAnimationFrame(animationId);
  });
</script>

<style>
  .overview-diagram-canvas {
    position: relative;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-radius: 12px;
    overflow: hidden;
  }

  canvas {
    display: block;
    width: 100%;
    height: auto;
  }

  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  @keyframes flowPath {
    0% {
      offset-distance: 0%;
      opacity: 0;
    }
    10% {
      opacity: 1;
    }
    90% {
      opacity: 1;
    }
    100% {
      offset-distance: 100%;
      opacity: 0;
    }
  }

  .particle {
    animation: flowPath 3s ease-in-out infinite;
  }

  /* Input particles */
  .input-p1 { offset-path: path('M 41,110 C 100,110 140,150 180,175 Q 220,190 280,200'); animation-duration: 2.8s; }
  .input-p2 { offset-path: path('M 41,155 C 100,155 140,165 180,185 Q 220,195 280,200'); animation-duration: 2.6s; }
  .input-p3 { offset-path: path('M 41,200 C 100,200 140,200 180,200 Q 220,200 280,200'); animation-duration: 2.4s; }
  .input-p4 { offset-path: path('M 41,245 C 100,245 140,235 180,215 Q 220,205 280,200'); animation-duration: 2.6s; }
  .input-p5 { offset-path: path('M 41,290 C 100,290 140,260 180,225 Q 220,210 280,200'); animation-duration: 3s; }

  /* Stream particles */
  .stream-p1 { offset-path: path('M 150,200 Q 300,180 450,200 Q 600,220 750,200'); animation-duration: 3.5s; }
  .stream-p2 { offset-path: path('M 150,200 Q 300,220 450,200 Q 600,180 750,200'); animation-duration: 4s; }
  .stream-p3 { offset-path: path('M 150,200 Q 300,190 450,210 Q 600,190 750,200'); animation-duration: 3.8s; }

  /* Agent particles - bidirectional flow (matching smooth arc paths) */
  /* Materializer (top-left) */
  .agent-m-up { offset-path: path('M 320,190 Q 380,150 330,108'); animation-duration: 2s; }
  .agent-m-down { offset-path: path('M 250,108 Q 200,150 260,190'); animation-duration: 2.2s; }

  /* Fetcher (top-right) */
  .agent-f-up { offset-path: path('M 580,190 Q 520,150 570,108'); animation-duration: 2s; }
  .agent-f-down { offset-path: path('M 650,108 Q 700,150 640,190'); animation-duration: 2.2s; }

  /* Enricher (bottom-left) */
  .agent-e-down { offset-path: path('M 320,210 Q 380,250 330,292'); animation-duration: 2s; }
  .agent-e-up { offset-path: path('M 250,292 Q 200,250 260,210'); animation-duration: 2.2s; }

  /* Pattern Detector (bottom-right) */
  .agent-pd-down { offset-path: path('M 580,210 Q 520,250 570,292'); animation-duration: 2s; }
  .agent-pd-up { offset-path: path('M 650,292 Q 700,250 640,210'); animation-duration: 2.2s; }

  /* Output particles - adjusted for new output positions */
  .output-p1 { offset-path: path('M 700,200 Q 728,165 755,130'); animation-duration: 2.3s; }
  .output-p2 { offset-path: path('M 710,200 Q 733,188 755,175'); animation-duration: 2.5s; }
  .output-p3 { offset-path: path('M 710,200 Q 733,210 755,220'); animation-duration: 2.4s; }
  .output-p4 { offset-path: path('M 700,200 Q 728,240 755,265'); animation-duration: 2.7s; }

  /* Agent hover effect */
  .agent rect {
    transition: filter 0.3s ease;
    pointer-events: auto;
  }
  .agent:hover rect {
    filter: drop-shadow(0 0 6px #3b82f6);
  }

  @media (prefers-reduced-motion: reduce) {
    .particle {
      animation: none;
      opacity: 0;
    }
  }
</style>
